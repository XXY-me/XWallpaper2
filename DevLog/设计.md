# XWallpaper2开发日志
## 设计目的
XWallpaper程序由于使用的是ffmpeg+mfc开发的，它只能使用视频来做动态背景。最近想了想能不能做一些不一样的东西，例如一些网站上的动态背景，看起来很炫。想着能不能把这些东西给移植到桌面上来作为桌面背景，而且来说js动画这种东西制作起来还是相对简单的，再有网上这些模板代码也多的是。
## 设计思路
在上一个版本中是创建了一个视频播放窗口作为桌面背景窗口的子窗口，那么能不能使用一个webview窗口来作为桌面背景窗口的子窗口来运行这些js动画或者播放视频。
## 开始干活
基本核心功能很好实现，已经将webview窗口加入桌面背景窗口，基本实现暂停开始功能。剩下的就是体力活了，加上一个列表控制等。

## 坑和技巧
1. qt的webengineview并不支持播放视频，网上一些文章说是没有解码插件。但提供的解决方案都是基于chrome40版本的webengineview。而且webengineview的效率并不怎么高，在chrome浏览器中能流畅运行的特效代码在webengineview中显得有些卡顿。具体怎么解决还需要想办法。
2. 使用js查看chrome的版本号
   ```html
    <body>
        <li id="chromeVer" style="color:rgb(255, 0, 0);"></li>
    </body>
    <script>
       // 获取谷歌浏览器版本
        function getChromeVersion() {
            var arr = navigator.userAgent.split(' '); 
            var chromeVersion = '';
            for(var i=0;i < arr.length;i++){
                if(/chrome/i.test(arr[i]))
                chromeVersion = arr[i]
            }
            obj = document.getElementById("chromeVer");
            obj.innerHTML = chromeVersion;
        }
        getChromeVersion();
    </script>
   ```
3. qt连接信号的几种方式   
    ```c++
    //使用SIGNAL和SLOT宏
    /*
    其中SIGNAL和SLOT宏生成的是const char*字符串。
    这种连接方式调用的是connect方法的这几种重载形式。
    [static] QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)
    [static] QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const
    注意，下面这个方法不是静态方法
    QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type = Qt::AutoConnection) const
    */
    
    //这种连接方式中形参只能写类型，不能写参数名。否则会连接失败.
    connect( btn, SIGNAL(clicked(bool)), SLOT(onClicked(bool)));         //连接成功
    connect( btn, SIGNAL(clicked(bool checked)), SLOT(onClicked(bool checked)));         //连接失败

    //使用成员函数指针连接
    /*
    这种连接方式调用的是connect方法的这种重载形式。
    [static] QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)
    */
    connect(btn, &QPushButton::clicked, this, &MainWindow::onBtnClicked);

    //使用函数指针连接
    /*
    这种连接方式调用的是connect方法的这两种种重载形式。
    [static] QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
    [static] QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type = Qt::AutoConnection)
    */
    //官方文档中给出的例子1
    void someFunction();
    QPushButton *button = new QPushButton;
    QObject::connect(button, &QPushButton::clicked, someFunction);
    //官方文档中给出的例子2 使用Lambda表达式
    QByteArray page = ...;
    QTcpSocket *socket = new QTcpSocket;
    socket->connectToHost("qt-project.org", 80);
    QObject::connect(socket, &QTcpSocket::connected, [=] () {
            socket->write("GET " + page + "\r\n");
        });
   ```
   另外信号还可以连接信号，可以使用SIGNAL宏也可以使用成员方法指针的形式连接。  
   有时候有些临时创建使用的控件使用Lambda表达式的方式连接也是很方便。
4. QFile::readLine()  
    QFile::readLine()函数返回一行数据的同时也会将换行符返回。即返回值的结尾字符一定是换行符，读取到文件结尾的情况下除外。
